% intro.tex

{\bf AG:} have added basic points to highlight, terminology needs to be cleaned up, will add more background and highlights after experiments \\

One approach for verifying secure information flow is to convert it into a safety verification problem on a ``self-composition'' of the program, where two copies of the program are created on which a safety property is checked~\cite{BartheCsfw04}. For example, to check for information leaks, the low-security variables are initialized to identical values in the two copies of the program, while the high-security variables are unconstrained and can take different values. The safety check ensures that in all executions of the program with the two copies, the values of the low-security variables are identical at the end of the program, i.e., there is no information leak from high-security to low-security variables. The self-composition approach is a general approach for checking hyper-properties, and has been recently applied for checking constant-time implementations of secure 
code~\cite{AlmeidaUsenix16}. 

Although the self-composition reduction is sound and complete, it is challenging to perform safety verification, especially on two copies of a program. An improvement was suggested by Terauchi and Aiken~\cite{TerauchiSas05}, where they combined the self-composition approach with type analysis to make copies of (portions of) the program in a manner that is more friendly for software verifiers. For example, if a loop condition is of type low-security, then the loop bodies are duplicated inside a single loop. This has the effect of keeping corresponding variables in the two copies of the program near each other, which can be useful in deriving invariants to aid safety verification. 

In this paper, we aim to further improve the self-composition approach by making it \emph{lazier}, in contrast to an eager upfront translation into two copies of a program. This lazy duplication is enabled by dynamic taint propagation, which is performed along with an unrolling of the program during bounded model checking (BMC)~\cite{BiereBmc}. Dynamic taint propagation has the benefit of being more precise than static type-based analysis. By combining it with BMC, it is guaranteed to cover all possible (bounded) program executions, unlike other dynamic approaches that cover only the tested executions. This also allows us to leverage existing interpolant-based verification methods for proving correctness over unbounded executions.

We also propose a specialized early termination check for the BMC-based approach. In secure programs, it is often the case that sensitive information is propagated in a very localized context, and conditions exist that squash its propagation any further. An eager self-composition approach does not exploit this, but in effect delays the security property check to take place at the end of the two programs. Indeed, it depends on the software verifier to perform any property-related slicing or other optimizations. We believe that general software verifiers are not equipped to leverage such conditions. We formulate our early termination check in terms of taint queries on live variables during program unrolling. In practice, this check is often successful, leading to much saved effort in comparison to performing a full safety check. 

To summarize, our lazy self-composition approach based on BMC provides the following advantages for security verification:
\begin{itemize}\item It performs \emph{dynamic taint propagation} to determine precise security types while unrolling the program during BMC. This information is more precise than static type-based analysis (which loses precision due to path-insensitive analyses), and covers all possible (bounded) program executions unlike dynamic taint analysis that covers only the tested executions. 
\item It performs \emph{lazy self-composition} by querying security types during program unrolling and using it to avoid or optimize duplicated code. The goals are similar to the Terauchi-Aiken approach, but our dynamic type queries yield more precise information and our duplication optimizations are more effective. (AG: will need to justify this.)
\item It performs an \emph{early termination} check for information flow, whereby it is guaranteed that the security property is correct without any further unrolling.
\end{itemize}
Our security verifier targets rich specifications in terms of low-security and high-security variables/locations, predicates that allow information downgrading in certain contexts, checking for constant-time implementations, etc. It leverages modern SMT-based verification techniques, including (potential) use of interpolants to derive proofs of correctness. We have implemented the security verifier as part of the SeaHorn verification platform~\cite{SeahornCav15}, which represents programs as CHC (Constrained Horn Clause) rules. It has a frontend based on LLVM~\cite{llvm}, and backends to Z3~\cite{z3tool} and mu-Z3~\cite{muz3tool}.
